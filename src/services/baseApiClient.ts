//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Gets the all groups using the specified per page.
     * @param version The requested API version
     * @param name (optional) The name of groups.
     * @param perPage (optional) The per page.
     * @return Gets the all groups using the specified parameters
     */
    getAllGroups(version: string, name?: string | undefined, perPage?: number | undefined, signal?: AbortSignal): Promise<GroupDto[]> {
        let url_ = this.baseUrl + "/api/v{version}/groups?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "perPage=" + encodeURIComponent("" + perPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllGroups(_response);
        });
    }

    protected processGetAllGroups(response: Response): Promise<GroupDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GroupDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GroupDto[]>(null as any);
    }

    /**
     * Gets the groups projects using the specified id.
     * @param id The id.
     * @param version The requested API version
     * @param page (optional) The page.
     * @param perPage (optional) The per page.
     * @return Gets the groups projects using the specified id
     */
    getProjectsByGroupId(id: number, version: string, page?: number | undefined, perPage?: number | undefined, signal?: AbortSignal): Promise<ProjectDto[]> {
        let url_ = this.baseUrl + "/api/v{version}/groups/{id}/projects?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "perPage=" + encodeURIComponent("" + perPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectsByGroupId(_response);
        });
    }

    protected processGetProjectsByGroupId(response: Response): Promise<ProjectDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProjectDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectDto[]>(null as any);
    }

    /**
     * Gets the sub groups of a group using the specified identifier.
     * @param id The group identifier.
     * @param version The requested API version
     * @return Gets the sub groups of a group by its identifier
     */
    getSubGroupsByGroupId(id: number, version: string, signal?: AbortSignal): Promise<SubGroupDto[]> {
        let url_ = this.baseUrl + "/api/v{version}/groups/{id}/subgroups";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSubGroupsByGroupId(_response);
        });
    }

    protected processGetSubGroupsByGroupId(response: Response): Promise<SubGroupDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SubGroupDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubGroupDto[]>(null as any);
    }

    /**
     * Lists the pipeline jobs using the specified project id.
     * @param projectId The project id.
     * @param pipelineId The pipeline id.
     * @param version The requested API version
     * @return Lists the pipeline jobs using the specified project id
     */
    listPipelineJobs(projectId: number, pipelineId: number, version: string, signal?: AbortSignal): Promise<JobDto[]> {
        let url_ = this.baseUrl + "/api/v{version}/projects/{projectId}/pipelines/{pipelineId}/jobs";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (pipelineId === undefined || pipelineId === null)
            throw new Error("The parameter 'pipelineId' must be defined.");
        url_ = url_.replace("{pipelineId}", encodeURIComponent("" + pipelineId));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListPipelineJobs(_response);
        });
    }

    protected processListPipelineJobs(response: Response): Promise<JobDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as JobDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobDto[]>(null as any);
    }

    /**
     * Lists the pipeline bridges using the specified project id.
     * @param projectId The project id.
     * @param pipelineId The pipeline id.
     * @param version The requested API version
     * @return Lists the pipeline jobs using the specified project id
     */
    listPipelineBridges(projectId: number, pipelineId: number, version: string, signal?: AbortSignal): Promise<BridgeDto[]> {
        let url_ = this.baseUrl + "/api/v{version}/projects/{projectId}/pipelines/{pipelineId}/bridges";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (pipelineId === undefined || pipelineId === null)
            throw new Error("The parameter 'pipelineId' must be defined.");
        url_ = url_.replace("{pipelineId}", encodeURIComponent("" + pipelineId));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListPipelineBridges(_response);
        });
    }

    protected processListPipelineBridges(response: Response): Promise<BridgeDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BridgeDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BridgeDto[]>(null as any);
    }

    /**
     * Plays the job using the specified project id.
     * @param projectId The project id.
     * @param jobId The job id.
     * @param version The requested API version
     * @return Runs the job using the specified project id
     */
    playJob(projectId: number, jobId: number, version: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/v{version}/projects/{projectId}/jobs/{jobId}/play";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPlayJob(_response);
        });
    }

    protected processPlayJob(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Plays the job using the specified project id.
     * @param projectId The project id.
     * @param jobId The job id.
     * @param version The requested API version
     * @return Runs the job using the specified project id
     */
    retryJob(projectId: number, jobId: number, version: string, signal?: AbortSignal): Promise<JobDto[]> {
        let url_ = this.baseUrl + "/api/v{version}/projects/{projectId}/jobs/{jobId}/retry";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (jobId === undefined || jobId === null)
            throw new Error("The parameter 'jobId' must be defined.");
        url_ = url_.replace("{jobId}", encodeURIComponent("" + jobId));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRetryJob(_response);
        });
    }

    protected processRetryJob(response: Response): Promise<JobDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            result201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as JobDto[];
            return result201;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<JobDto[]>(null as any);
    }

    /**
     * Creates the pipeline using the specified project id.
     * @param projectId The project id.
     * @param version The requested API version
     * @param body (optional) The command.
     * @return Creates the pipeline using the specified project id
     */
    createPipeline(projectId: number, version: string, body?: CreatePipelineCommand | undefined, signal?: AbortSignal): Promise<PipelineDto> {
        let url_ = this.baseUrl + "/api/v{version}/projects/{projectId}/pipeline";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/vnd.restful+json",
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreatePipeline(_response);
        });
    }

    protected processCreatePipeline(response: Response): Promise<PipelineDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PipelineDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PipelineDto>(null as any);
    }

    /**
     * Gets the pipeline using the specified project id.
     * @param projectId The project id.
     * @param pipelineId The pipeline id.
     * @param version The requested API version
     * @return Gets the pipeline using the specified project id
     */
    getPipeline(projectId: number, pipelineId: number, version: string, signal?: AbortSignal): Promise<PipelineDto> {
        let url_ = this.baseUrl + "/api/v{version}/projects/{projectId}/pipelines/{pipelineId}";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (pipelineId === undefined || pipelineId === null)
            throw new Error("The parameter 'pipelineId' must be defined.");
        url_ = url_.replace("{pipelineId}", encodeURIComponent("" + pipelineId));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPipeline(_response);
        });
    }

    protected processGetPipeline(response: Response): Promise<PipelineDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PipelineDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PipelineDto>(null as any);
    }

    /**
     * Lists the pipelines using the specified project id.
     * @param projectId The project id.
     * @param version The requested API version
     * @return Lists the pipelines using the specified project id
     */
    listPipelines(projectId: number, version: string, signal?: AbortSignal): Promise<PipelineDto[]> {
        let url_ = this.baseUrl + "/api/v{version}/projects/{projectId}/pipelines";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processListPipelines(_response);
        });
    }

    protected processListPipelines(response: Response): Promise<PipelineDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PipelineDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PipelineDto[]>(null as any);
    }

    /**
     * Gets the last pipeline using the specified project id.
     * @param projectId The project id.
     * @param version The requested API version
     * @return The last pipeline using the specified project id
     */
    getLastPipeline(projectId: number, version: string, signal?: AbortSignal): Promise<PipelineDto> {
        let url_ = this.baseUrl + "/api/v{version}/projects/{projectId}/pipeline/latest";
        if (projectId === undefined || projectId === null)
            throw new Error("The parameter 'projectId' must be defined.");
        url_ = url_.replace("{projectId}", encodeURIComponent("" + projectId));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLastPipeline(_response);
        });
    }

    protected processGetLastPipeline(response: Response): Promise<PipelineDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PipelineDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PipelineDto>(null as any);
    }

    /**
     * Gets the all projects using the specified name.
     * @param version The requested API version
     * @param name (optional) The name.
     * @param page (optional) The page.
     * @param perPage (optional) The per page.
     * @return Gets the all projects using the specified parameters
     */
    getAllProjects(version: string, name?: string | undefined, page?: number | undefined, perPage?: number | undefined, signal?: AbortSignal): Promise<ProjectDto[]> {
        let url_ = this.baseUrl + "/api/v{version}/projects?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (perPage === null)
            throw new Error("The parameter 'perPage' cannot be null.");
        else if (perPage !== undefined)
            url_ += "perPage=" + encodeURIComponent("" + perPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProjects(_response);
        });
    }

    protected processGetAllProjects(response: Response): Promise<ProjectDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProjectDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectDto[]>(null as any);
    }

    /**
     * Gets the projects by ids using the specified project ids.
     * @param id The project ids.
     * @param version The requested API version
     * @return Gets the project using the specified id
     */
    getProjectById(id: number, version: string, signal?: AbortSignal): Promise<ProjectDto> {
        let url_ = this.baseUrl + "/api/v{version}/projects/projects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectById(_response);
        });
    }

    protected processGetProjectById(response: Response): Promise<ProjectDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProjectDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectDto>(null as any);
    }

    /**
     * Gets the projects by ids using the specified project ids.
     * @param version The requested API version
     * @param projectIds (optional) The project ids.
     * @return Gets the projects using the specified ids
     */
    getProjectsByIds(version: string, projectIds?: number[] | undefined, signal?: AbortSignal): Promise<ProjectDto[]> {
        let url_ = this.baseUrl + "/api/v{version}/projects/projects?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (projectIds === null)
            throw new Error("The parameter 'projectIds' cannot be null.");
        else if (projectIds !== undefined)
            projectIds && projectIds.forEach(item => { url_ += "projectIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectsByIds(_response);
        });
    }

    protected processGetProjectsByIds(response: Response): Promise<ProjectDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProjectDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectDto[]>(null as any);
    }

    /**
     * Gets the project group parent by project id using the specified id.
     * @param id The id.
     * @param version The requested API version
     * @return Gets the projects projects using the specified id
     */
    getProjectGroupParentByProjectId(id: number, version: string, signal?: AbortSignal): Promise<ProjectParentGroupDto[]> {
        let url_ = this.baseUrl + "/api/v{version}/projects/{id}/groups";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProjectGroupParentByProjectId(_response);
        });
    }

    protected processGetProjectGroupParentByProjectId(response: Response): Promise<ProjectParentGroupDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProjectParentGroupDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectParentGroupDto[]>(null as any);
    }

    /**
     * Gets the last project branches using the specified id.
     * @param id The id.
     * @param version The requested API version
     * @return Gets last six the projects branches using the specified id
     */
    getLastProjectBranches(id: number, version: string, signal?: AbortSignal): Promise<ProjectBranchDto[]> {
        let url_ = this.baseUrl + "/api/v{version}/projects/{id}/branches";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLastProjectBranches(_response);
        });
    }

    protected processGetLastProjectBranches(response: Response): Promise<ProjectBranchDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProjectBranchDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProjectBranchDto[]>(null as any);
    }

    /**
     * Returns the search results based on the provided parameters.
     * @param version The requested API version
     * @param body (optional) The body.
     * @return Returns the search results based on the provided parameters.
     */
    search(version: string, body?: SearchTermsBody | undefined, signal?: AbortSignal): Promise<SearchTermsQueryDto[]> {
        let url_ = this.baseUrl + "/api/v{version}/terms/search";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/vnd.restful+json",
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<SearchTermsQueryDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SearchTermsQueryDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchTermsQueryDto[]>(null as any);
    }

    /**
     * Gets the token info using the specified token.
     * @param version The requested API version
     * @param token (optional) The token.
     * @return Gets the all groups using the specified parameters
     */
    getTokenInfo(version: string, token?: string | undefined, signal?: AbortSignal): Promise<TokenInfoDto> {
        let url_ = this.baseUrl + "/api/v{version}/token/info?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTokenInfo(_response);
        });
    }

    protected processGetTokenInfo(response: Response): Promise<TokenInfoDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenInfoDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenInfoDto>(null as any);
    }

    /**
     * Gets the token info using the specified token.
     * @param version The requested API version
     * @return Gets the all groups using the specified parameters
     */
    getUserInfo(version: string, signal?: AbortSignal): Promise<UserInfoDto> {
        let url_ = this.baseUrl + "/api/v{version}/users/info";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/vnd.restful+json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserInfo(_response);
        });
    }

    protected processGetUserInfo(response: Response): Promise<UserInfoDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserInfoDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserInfoDto>(null as any);
    }
}

/** The bridge response class. */
export interface BridgeDto {
    /** Gets or sets the value of the id. */
    id?: number;
    /** Gets or sets the value of the status. */
    status?: string | undefined;
    /** Gets or sets the value of the name. */
    name?: string | undefined;
    /** Gets or sets the value of the web url. */
    webUrl?: string | undefined;
}

/** The commit dto. */
export interface CommitDto {
    /** Gets or inits the value of the id. */
    id?: string | undefined;
    /** Gets or inits the value of the short id. */
    shortId?: string | undefined;
    /** Gets or inits the value of the created at. */
    createdAt?: string | undefined;
    /** Gets or inits the value of the title. */
    title?: string | undefined;
    /** Gets or inits the value of the message. */
    message?: string | undefined;
    /** Gets or inits the value of the committer name. */
    committerName?: string | undefined;
    /** Gets or inits the value of the committed date. */
    committedDate?: string | undefined;
}

/** The create new pipeline command class. */
export interface CreatePipelineCommand {
    projectId?: number;
    ref?: string | undefined;
    pipelineVariables?: PipelineVariable[] | undefined;
}

/** The group dto. */
export interface GroupDto {
    id?: number;
    name?: string | undefined;
    path?: string | undefined;
    fullName?: string | undefined;
    parentId?: number | undefined;
}

/** The job response class. */
export interface JobDto {
    /** Gets or sets the value of the id. */
    id?: number;
    /** Gets or sets the value of the status. */
    status?: string | undefined;
    /** Gets or sets the value of the stage. */
    stage?: string | undefined;
    /** Gets or sets the value of the name. */
    name?: string | undefined;
    /** Gets or sets the value of the name. */
    webUrl?: string | undefined;
}

/** The pipeline dto class. */
export interface PipelineDto {
    /** Gets or sets the value of the id. */
    id?: number;
    /** Gets or sets the value of the status. */
    status?: string | undefined;
    /** Gets or sets the value of the ref. */
    ref?: string | undefined;
    /** Gets or sets the value of the sha. */
    sha?: string | undefined;
}

/** The pipeline variable class. */
export interface PipelineVariable {
    /** Gets or sets the value of the key. */
    key?: string | undefined;
    /** Gets or sets the value of the value. */
    value?: string | undefined;
}

/** The project branch dto. */
export interface ProjectBranchDto {
    /** Gets or inits the value of the name. */
    name?: string | undefined;
    commit?: CommitDto;
}

/** The project group dto. */
export interface ProjectDto {
    id?: number;
    defaultBranch?: string | undefined;
    name?: string | undefined;
    nameWithNamespace?: string | undefined;
    path?: string | undefined;
    pathWithNamespace?: string | undefined;
    webUrl?: string | undefined;
}

/** The project dto. */
export interface ProjectParentGroupDto {
    id?: number;
    name?: string | undefined;
    fullName?: string | undefined;
}

/** The search terms body. */
export interface SearchTermsBody {
    term?: string | undefined;
    groupId?: number | undefined;
    filenamePattern?: string | undefined;
}

/** Represents a DTO for the SearchTermsCommand. */
export interface SearchTermsQueryDto {
    basename?: string | undefined;
    data?: string | undefined;
    path?: string | undefined;
    fileName?: string | undefined;
    branche?: string | undefined;
    startLine?: number;
    projectId?: number;
    projectName?: string | undefined;
    projectPath?: string | undefined;
}

/** The sub group dto. */
export interface SubGroupDto {
    id?: number;
    name?: string | undefined;
    path?: string | undefined;
}

/** The token info dto. */
export interface TokenInfoDto {
    resourceOwnerId?: number;
    scope?: string[] | undefined;
    expiresIn?: number;
    createdAt?: number;
}

/** The user info dto. */
export interface UserInfoDto {
    id?: number;
    userName?: string | undefined;
    name?: string | undefined;
    avatarUrl?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}